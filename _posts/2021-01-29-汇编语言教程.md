---
layout:     post
title:      汇编语言教程
subtitle:   汇编好难啊
date:       2021-01-29
author:     JZH
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 计算机
    - 教程
    - 汇编
---
## 汇编语言笔记

*本笔记由jzh整理《汇编语言（基于X86处理器》而成，转载需申明*

[TOC]

### 0.本书导读



------



### 1.基本概念

#### 1.1.欢迎来到汇编语言的世界

1.环境配置：Microsoft宏汇编器（*MASM*）或Microsoft visual studio

2.汇编器：将汇编语言转化为机器语言

3.链接器：将汇编器生成的单个文件组成为一个可执行文件

4.调试器：检查寄存器和内存状态

#### 1.2.虚拟机概念

1.虚拟机概念是一种说明计算机硬件和软件关系的有效方法

2.虚拟机层次概念：

|       level4 ： 高级语言        |
| :-----------------------------: |
|      **level3 ：汇编语言**      |
| **level2 ： 指令集加购（IAS）** |
|      **level1 ：数字逻辑**      |

#### 1.3.数据表示

1.二进制整数：无符号二进制整数；二进制数与十进制数互转；二进制加法；整数存储大小

2.十六进制整数：无符号十六进制整数；无符号十六进制数与十进制数互转；十六进制加法

3.有符号二进制数：补码；加减法

4.字符储存：ASCII；UTF-8；UTF-16; UTF-32

#### 1.4.布尔表达式

1.与或非：not； and； or

#### 1.5.小结

1.**汇编器**：一种程序，用于把源程序从汇编语言转换为机器语言

2.**链接器**：将汇编器生成的单个文件组成为一个可执行文件

3.**调试器**：检查寄存器和内存状态

##### tips

1.汇编语言与机器语言一一对应

2.有一说一，我都不知道这本书作者第一章讲了些啥，计算机组成原理都加上了，搞得我都快劝退了，呜呜呜

3.下一章还不是汇编语言，~~我裂开了~~

4。我的建议是第一章和第二章先略过吧~~（误）~~

------



### 2.X86处理器架构

#### 2.1：一般概念

1.X86处理器的型号：intel32； intel64；（大概率你用的电脑也是x86的吧）

2.寄存器：直接位于CPU内的高速储存位置的存储器，访问速度远高于传统存储器

2.时钟：对CPU内部操作与系统其他组件进行同步

3.控制单元（CU）：协调参与机器指令执行的步骤序列

4.算术逻辑单元（ALU）：执行算数运算

5.内存存储单元：用于在程序运行时保存指令和数据

6.总线：一组并行线，将数据从计算机一个部分传到另一个部分

​	6.1数据总线：传指令和数据

​	6.2控制总线：对设备进行同步

​	6.3地址总线：保存指令和数据地址

7.指令执行周期：其步骤主要分为**取指，译码，执行**
8.读取内存、加载、执行程序

#### 2.2: 32位X86处理器

1.操作模式：保护模式，虚拟8086模式，实地址模式，系统管理模式

​	1）保护模式：最安全

​	2）虚拟8086模式：既安全又是实地址

​	3）实地址模式：直接访问系统内存和硬盘

2.执行环境

​	1）**通用寄存器**(球球了，这个记住吧，真的很重要)

| 32位 | 16位 | 8位（高） | 8位（低） |
| ---- | ---- | --------- | --------- |
| EAX  | AX   | AH        | AL        |
| EBX  | BX   | BH        | BL        |
| ECX  | CX   | CH        | CL        |
| EDX  | DX   | DH        | DL        |

​		**tips**

​		1）乘法默认EAX

​		2）CPU默认用ECX做循环（参见后面的loop）

​		3)   ESP用于寻址堆栈数据

​		4）ESI和EDI用于高速存储器传输指令

​		5）EBP引用堆栈的函数参数和局部变量

​	2）段寄存器

​	3）指令指针

​	4）EFLAGS寄存器：设置标志位，EFLAGS为1；清除标志位，EFLAGS为0

​	5）控制标志位

​	6）状态标志位

​			1.进位（CF）

​			2.溢出（OF）

​			3.符号（SF）

​			4.零（ZF）

​			5.辅助进位（AC)

​			6.奇偶校验（PF）

3.MMX寄存器：单指令，多数据

4.XMM寄存器：浮点单元（FPU）

#### 2.3 64位X86-64处理器

基本上和32位差不多

**除了：**

16个64位通用寄存器（32只有8个）

8个80位浮点寄存器

1个64位RFLAGS（但只能用低32位，~~好鸡肋啊~~）

1个64位RIP

8个64位MMX

16个128位XMM（32位只有8个XMM）

| 操作数大小 | 可用寄存器                                                   |
| ---------- | ------------------------------------------------------------ |
| 8位        | AL;BL;CL;DL;DIL;SIL;BPL;SPL;R8L;R9L;R10L;R11L;R12L;R13L;R14L;R15L; |
| 16位       | AX;BX;CX;DX;DI;SI;BP;SP;R8W;R9W;R10W;R11W;R12W;R13W;R14W;R15W |
| 32位       | EAX;EBX;ECX;EDX;EDI;ESI;EBP;ESP;R8D;R9D;R10D;R11D;R12D;R13D;R14D;R15D |
| 64位       | RAX;RBX;RCX;RDX;RDI;RSI;RBP;RSP;R8;R9;R10;R11;R12;R13;R14;R15 |

#### 2.4 典型x86计算机组件

1.主板

2.内存

#### 2.5 输入输出系统

1.I/O访问层次

#### 2.6 小结

1.32位和64位寄存器，好好搞，本章就这个是重点，其他都是废话

2.寄存器：直接位于CPU内的高速储存位置的存储器，访问速度远高于传统存储器

2.时钟：对CPU内部操作与系统其他组件进行同步

3.控制单元（CU）：协调参与机器指令执行的步骤序列

4.算术逻辑单元（ALU）：执行算数运算

5.内存存储单元：用于在程序运行时保存指令和数据

6.总线：一组并行线，将数据从计算机一个部分传到另一个部分

​	6.1数据总线：传指令和数据

​	6.2控制总线：对设备进行同步

​	6.3地址总线：保存指令和数据地址

##### tips

我现在严重怀疑作者想要劝退一些人，才这么写。前两章和汇编关系不是很大，但对我而言已经很劝退了，是不是我太菜了，，我裂开了。强烈建议跳过这俩，我吐了

第一章重点是配置一下环境

第二章重点是看看寄存器，稍微理解一下

没了。。。

对了，下章多看看，比前面硬核，真的开始了汇编之旅

------

### 3.汇编语言基础

#### 3.1 基本语言元素

先来一个汇编语言代码

```asm
main PROC
	MOV eax,5
	add eax,6
	
	INVOKE ExitProcess,0
main ENDP
```

就是把5移动到 EAX 寄存器中，然后再把6加到 EAX 寄存器中，就结束了

*（震惊！！！你的第一个汇编语言代码居然不是hello world）*

接下来，我们添加一个变量吧

```asm
.data
sum DWORD 0
.code
main PROC
	mov eax,5
	add eax,6
	mov sum,eax
	
	INVOKE ExitProcess,0
main ENDP
```

就是sum = 5 + 6 

啊啊啊啊，好累啊啊，我死了

和其他语言一样，我们先从常量和变量开始吧

1.整数常量

​	[{+|-}]数字[数制系统]

​	垃圾总述，直接上例子

​	E.G.

​	26 10

​	26d 10

​	1101001 10

​	1101001b 2

​	42q 8

​	42o 8

​	1Ah 16 

​	0A3h 16 **注意：如果16进制开头是字母，要加前导0**

2.整型常量表达式

| 运算符 | 名称                        | 优先级 |
| ------ | --------------------------- | ------ |
| （）   | 圆括号                      | 1      |
| +，-   | 正负（+1，-4）              | 2      |
| *，/   | 乘除                        | 3      |
| MOD    | 取mod*（泪目，回到高中VB）* | 3      |
| +， -  | 加减                        | 4      |

3.实数常量

​	[sign]integer.[integer]\[exponent]

​	直接上例子吧

​	2.

​	+3.0

​	-44.2E+05

​	26.E5

**小数点别忘了，不管怎么样都要有**

4.字符(串)常量（学完这个就会hello world了）

​	‘hello world’

​	"hello world"

​	"a 'hello' b"

​	'a "hello" b'

​	这个和python好像啊，**单双引号可以混用**

5.保留字：别用就可以了

6.标识符：就是约等于变量，现在可以这么理解

7.伪指令：嵌入源代码中的命令，由汇编器识别和执行

​	**不区分大小写**

​	E.G. .data .DATA .Data 是一样的

​	定义段：.data,.code等等

8.指令

​	标号（可选）

​	指令助记符（必选）

​	操作数（可选）

​	注释（可选）

​	[label:] mnemonic [operands] [;comment]

​	L1: mov ax, bx   ;move bx to ax

​	tips：NOP指令：空指令，用于对齐，对齐了，算起来快

#### 3.2 示例

```asm
; AddTwo.asm - 两个32位整数相加
; 第三章示例

.386									;32位程序
.model flat, stacall					;flag内存模式， stdcall调用规范
.stack 4096								;堆栈4096，一个内存页大小
ExitProcess PROTO, dwExitCode:DWORD		;声明结束标准

.code
main PROC
	mov eax,5
	add eax,6
	
	INVOKE ExitProcess,0
main ENDP
END main
```

#### 3.3 汇编、链接和运行程序

1.汇编-链接-执行周期

2.列表文件：包括程序源文件副本，行号，每条指令的数字地址，每条指令的机器代码字节和符号表

```asm
; AddTwo.asm - 两个32位整数相加
; 第三章示例

.386									;32位程序
.model flat, stacall					;flag内存模式， stdcall调用规范
.stack 4096								;堆栈4096，一个内存页大小
ExitProcess PROTO, dwExitCode:DWORD		;声明结束标准

00000000		.code
00000000		main PROC
00000000 B8 00000005	mov eax,5
00000005 83 C0 06		add eax,6
	
						INVOKE ExitProcess,0
00000008 6A 00			push	+00000000h
0000000A E8 00000000 E	call ExitProcess
0000000F				main ENDP
						END main
```

invoke伪指令使得汇编器生成PUSH和CALL语句

#### 3.4 定义数据

1.内部数据类型：按数据大小（字节、字、双字）、是否有符号、是整数还是实数

[name] directive initializer [,initializer]...

| 类型   | 用法       |
| ------ | ---------- |
| BYTE   | 8位无符号  |
| SBYTE  | 8位有符号  |
| WORD   | 16位无符号 |
| SWORD  | 16位有符号 |
| DWORD  | 32位无符号 |
| SDWORD | 32位有符号 |
| FWORD  | 48位       |
| QWORD  | 64位       |
| TBYTE  | 80位       |
| REAL4  | 32位IEEE   |
| REAL8  | 64位IEEE   |
| REAL10 | 80位IEEE   |

E.G.

count DWORD 12345	

就是count = 12345

2.伪指令

| 伪指令 | 用法           | 伪指令 | 用法           |
| ------ | -------------- | ------ | -------------- |
| DB     | 8位整数        | DQ     | 64位整数或实数 |
| DW     | 16位整数       | DT     | 80位整数       |
| DD     | 32位整数或实数 |        |                |

3.初始化

sum DWORD 0	就是把sum初始化为0

当然，如果你不愿意初始化的话，也可以用？去初始化

即sum DWORD ?



所以，，我们加个变量吧

```asm
; AddTwo.asm - 两个32位整数相加
; 第三章示例

.386									;32位程序
.model flat, stacall					;flag内存模式， stdcall调用规范
.stack 4096								;堆栈4096，一个内存页大小
ExitProcess PROTO, dwExitCode:DWORD		;声明结束标准

.data
sum DWORD 0

.code
main PROC
	mov eax,5
	add eax,6
	mov sum,eax
	
	INVOKE ExitProcess,0
main ENDP
END main
```

4.定义BYTE和SBYTE

BYTE和SBYTE都是8位的，所以我们添加进的数据也都是8位的

E.G.

value1 BYTE 'a'

value2 BYTE 0

value3 BYTE 255

value4 SBYTE -128

value5 SBYTE 127

5.偏移量

即该元素（的首元素）的位置，**记住这一点**

6.多初始值

如果我们要用数组的话，我们可以用一个变量去代表数组

E.G.

list1 BYTE 10,20,30,40

list2 BYTE  10,20,30,40

​		 BYTE  50,60,70,80

**这两种在现在是一样的，但记住，在未来，这俩还是有一点点区别的**

当然，我们也可以使用不同的基数来定义

list1 BYTE 10b,20,30o,40h

7.定义字符串

greeting1 BYTE "Good afternoon",0

请记住这个**0**，真的很重要
